import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;

import java.util.Random;

/**
 * Tests the {@link River} class's functionality.
 * Generated by BlueJ.
 * 
 * @author Jackson Eshbaugh
 * @version 02/10/2023
 */
public class RiverTest {

    /**
     * Creates a new TestRiver test class object.
     */
    public RiverTest() { }

    /**
     * Sets up before each test. Called before each
     * test is called.
     */
    @BeforeEach
    public void setUp() { }

    /**
     * Cleans up after each test. Called after the
     * conclusion of each test.
     */
    @AfterEach
    public void tearDown() { }
    
    /**
     * Tests the {@link River#getLength()} method.
     * Does the following 3 times:
     * <ol>
     *  <li>Generates a random {@code int} to serve as the river's length.</li>
     *  <li>Creates a new {@link River} object with the random length.</li>
     *  <li>Ensures that the {@link River#getLength()} returns the same random
     *      value we previously generated.</li>
     * </ol>
     */
    @Test
    @DisplayName("getLength()")
    public void testGetLength() {
        
        Random r = new Random();
        
        for(int i = 0; i < 2; ++i) {
            
            int length = r.nextInt(26);
            River river = new River(length);
            
            assertEquals(length, river.getLength());
            
        }
        
    }
    
    
    /**
     * Tests the {@link River#numEmpty()} method:
     * <ol>
     *  <li>Test a {@code River} with all empty slots.</li>
     *  <li>Test a {@code River} with some empty slots.</li>
     *  <li>Test a {@code River} with no empty slots.</li>
     * </ol>
     */
    @Test
    @DisplayName("numEmpty()")
    public void testNumEmpty() {
        
        River river = new River(10);
        
        // Empty all slots.
        for(int i = 0; i < 10; ++i) {
            river.river[i] = null;
        }
        
        assertEquals(10, river.numEmpty());
        
        
        // Fill 4 slots.
        river.river[0] = new Fish();
        river.river[2] = new Fish();
        river.river[3] = new Fish();
        river.river[9] = new Fish();
        
        assertEquals(6, river.numEmpty());
        
        // Fill all slots.
        for(int i = 0; i < 10; ++i) {
            river.river[i] = new Bear();
        }
        
        assertEquals(0, river.numEmpty());
        
    }
    
    /**
     * Tests the {@link River#addRandom(Animal)} method:
     * <ol>
     *  <li>Test a {@code River} with all empty slots.</li>
     *  <li>Test a {@code River} with some empty slots.</li>
     *  <li>Test a {@code River} with no empty slots.</li>
     *  <li>Ensure that an {@code Animal} added will not
     *      move until the next cycle.</li>
     * </ol>
     */
    @Test
    @DisplayName("addRandom(Animal)")
    public void testAddRandom() {
        
        River river = new River(10);
        
        // Empty all slots.
        for(int i = 0; i < 10; ++i) {
            river.river[i] = null;
        }
        
        assertEquals(10, river.numEmpty());
        assertTrue(river.addRandom(new Fish()));
        assertEquals(9, river.numEmpty()); // Adding the Fish should have reduced the number of empty slots by 1.
        String toString = river.toString();
        
        // Make sure that Animals added don't move.
        river.updateRiver();
        assertEquals(toString, river.toString());
        
        // Empty all slots (to ensure that exactly 4 slots are filled).
        for(int i = 0; i < 10; ++i) {
            river.river[i] = null;
        }
        
        // Fill 4 slots.
        river.river[0] = new Fish();
        river.river[2] = new Fish();
        river.river[3] = new Fish();
        river.river[9] = new Fish();
        
        assertEquals(6, river.numEmpty());
        
        assertTrue(river.addRandom(new Fish()));
        assertEquals(5, river.numEmpty());
        
        
        // Fill all slots.
        for(int i = 0; i < 10; ++i) {
            river.river[i] = new Bear();
        }
        
        assertEquals(0, river.numEmpty());
        assertFalse(river.addRandom(new Fish()));
        assertEquals(0, river.numEmpty());
        
        
    }
    
    
    /**
     * Tests the {@link River#updateRiver()} method:
     * <ol>
     *  <li>Creates a {@code River} object with a length of {@code 30} and adds two {@link Animal} objects at indexes
     *      {@code 7} and {@code 22} (setting all other indexes to {@code null}). This is because the animals will be the furthest away from each other in a circular array
     *      when they are at quartiles 1 and 3.</li>
     *  <li>Calls {@link River#updateRiver()} precisely 10 times (After 5 years (at age = 5), the fish will die and the bear will continue to move until the 10th ).
     *      After each call, ensures that a valid move has been made by comparing indexes of each animal before and after (should remain on the interval
     *      {@code (currentIndex >= previousIndex - 1) && (currentIndex <= previousIndex + 1)} (not including a wraparound case) since only moves of 1 unit are allowed).</li>
     * </ol>
     */
    @Test
    @DisplayName("updateRiver()")
    public void testUpdateRiver() {
        
        River river = new River(30);
        
        // Clear the river.
        for(int i = 0; i < river.river.length; ++i) {
            river.river[i] = null;
        }
        
        river.river[7] = new Fish(0, Animal.Gender.MALE);
        river.river[22] = new Bear(0, Animal.Gender.MALE);
        
        int bearAge = 0, fishAge = 0;
        int oldBearIndex = 22, oldFishIndex = 7; // Save indexes for later comparison
        
        // Run 10 cycles
        for(int i = 0; i < 10; ++i) {
            river.updateRiver();
            
            bearAge++;
            fishAge++;
            
            int newBearIndex = -2, newFishIndex = -2;
            
            // Find the new indexes of the bear and fish.
            for(int j = 0; j < river.river.length; ++j) {
                if(river.river[j] instanceof Fish) {
                    newFishIndex = j;
                } else if(river.river[j] instanceof Bear) {
                    newBearIndex = j;
                }
            }
            
            // Either the indexes should be on the interval (currentIndex >= previousIndex - 1) && (currentIndex <= previousIndex + 1) (or a wraparound case)
            // or the age should be greater than the max age.
            
            boolean bearOK = false, fishOK = false;
            String troubleshoot = "";
            
            if((bearAge > 9) && (newBearIndex == -2)) // The bear is dead and is off the array.
                bearOK = true;
            else if((newBearIndex >= oldBearIndex - 1) && (newBearIndex <= oldBearIndex + 1))
                bearOK = true;
            else if((oldBearIndex == 0 && newBearIndex == 29) || (oldBearIndex == 29 && newBearIndex == 0)) // If we have a wraparound case
                bearOK = true;
            
            if((fishAge > 4) && (newFishIndex == -2)) // The fish is dead and is off the array.
                fishOK = true;
            else if((newFishIndex >= oldFishIndex - 1) && (newFishIndex <= oldFishIndex + 1))
                fishOK = true;
            else if((oldFishIndex == 0 && newFishIndex == 29) || (oldFishIndex == 29 && newFishIndex == 0)) // If we have a wraparound case
                fishOK = true;
                
            assertTrue(bearOK, "i: " + i + "; Troubleshoot: bearAge: " + bearAge + ", oldBearIndex: " + oldBearIndex + ", newBearIndex: " + newBearIndex);
            assertTrue(fishOK, "i: " + i + "; Troubleshoot: fishAge: " + fishAge + ", oldFishIndex: " + oldFishIndex + ", newFishIndex: " + newFishIndex);
            
            // Update the old indexes:
            oldFishIndex = newFishIndex;
            oldBearIndex = newBearIndex;
        }
        
        
    }
    
    /**
     * Tests the {@link River#updateCell(int)} method:
     * <ol>
     *  <li>Creates a {@code River} object with a length of {@code 10} and adds an {@link Animal} object (setting all other indexes to {@code null}).</li>
     *  <li>Calls {@link River#updateCell(int)} on each cell and ensures a legal move was taken:
     *      <ul>
     *       <li>If the cell is {@code null}, no action should have been taken (i.e., {@link River#toString()} should be the same before and after.</li>
     *       <li>If the cell is populated by an animal is at its max age, the cell (and array because there is only one animal here) should be filled
     *           with {@code null}.</li>
     *       <li>Else, the animal should move at most one unit in either direction.</li>
     *      </ul>
     *  </li>
     *  <li>Loops the above step for a total of {@code 10} executions, to ensure that animal death is accounted for.</li>
     * </ol>
     * <i>Completion of this test implies that the {@code River} class conforms to Rule 1 in ยง1.1.</i>
     */
    @Test
    @DisplayName("updateCell(int)")
    public void testUpdateCell() {
        
        River river = new River(10);
        
        // Clear the river.
        for(int i = 0; i < river.river.length; ++i) {
            river.river[i] = null;
        }
        
        river.river[5] = new Bear(0, Animal.Gender.MALE);
        
        int age = 0;
        
        // Run 10 cycles
        for(int i = 0; i < 10; ++i) {
            
            // Loop through each index in the array.
            for(int j = 0; j < river.river.length; ++j) {
                
                // Save reference to the animal for later.
                Animal a = river.river[j];
                String riverString = river.toString();
                
                river.updateCell(j);
                
                if(a == null) {
                    // Nothing should have changed; check the new toString() value.
                    assertEquals(riverString, river.toString());
                } else if(a instanceof Bear) {
                    // Done mostly formally, only a Bear was added and only a Bear could be there.
                    
                    ++age; // The bear's age has increased by 1.
                    
                    // Ensure that either j - 1, j, or j + 1 contains a.
                    
                    boolean valid = false;
                    
                    
                    // Handle edge cases first.
                    
                    if(age > 9) {
                        
                        // Here, we expect NOT to find the bear.
                        
                        
                        if(j - 1 == -1) {
                            // Checking at the end of the array.
                            if(river.river[river.river.length - 1] == null) {
                                valid = true;
                            }
                        } else if (j + 1 == river.river.length) {
                            // Check at the beginning of the array.
                            if(river.river[0] == null) {
                                valid = true;
                            }
                        } else {
                            // Now, handle other cases.
                            valid = ((river.river[j - 1] == null) || (river.river[j] == null) || (river.river[j + 1] == null)) ? true : false;
                        }
                        
                        // We can't use .equals() because it isn't null safe, but checking if objects
                        // are/aren't an instance of Bear also informs us if they're null or not (it's either null
                        // or a Bear here).
                        
                    } else if(j - 1 == -1) {
                        System.out.println("e");
                        // Checking at the end of the array.
                        if(river.river[river.river.length - 1] instanceof Bear) {
                            valid = true;
                        }
                    } else if (j + 1 == river.river.length) {
                        System.out.println("f");
                        // Check at the beginning of the array.
                        if(river.river[0] instanceof Bear) {
                            valid = true;
                        }
                    } else {
                        // Now, handle other cases.
                        valid = ((river.river[j - 1] instanceof Bear) || (river.river[j] instanceof Bear) || (river.river[j + 1] instanceof Bear)) ? true : false;
                    }
                    
                    assertTrue(valid);
                    
                } else {
                    fail("Niether a Bear nor null was in the cell.");
                }
            
                
                
            }
        }
        
        
    }
    
    
    /**
     * Tests the {@link River#processMove(int, int)} method:
     * <ol>
     *  <li><b>Tests Rule 2</b>: the collision of a {@link Bear} and {@link Fish}
     *      (in both directions).</li>
     *  <li><b>Tests Rule 3</b>: the collision of two {@link Animal} objects of
     *      the same gender and the same species.</li>
     *  <li><b>Tests Rule 4</b>: the collision of two animal objects of different\
     *      genders and same species (i.e., tests reproduction)</li>
     * </ol>
     */
    @Test
    @DisplayName("processMove(int, int)")
    public void testProcessMove() {
        
        /* === (1) Testing Rule 2: Collision of Bear and Fish === */
        
        River river = new River(2);
        river.river[0] = new Fish(2, Animal.Gender.MALE);
        river.river[1] = new Bear(3, Animal.Gender.FEMALE);
        
        assertEquals("FM2 BF3", river.toString());
        
        // Process the move of the fish to the bear.
        river.processMove(0, 1);
        assertEquals("--- BF3", river.toString());
        
        // Reset the river
        river.river[0] = new Fish(2, Animal.Gender.MALE);
        river.river[1] = new Bear(3, Animal.Gender.FEMALE);
        
        assertEquals("FM2 BF3", river.toString());
        
        // Process the move of the bear to the fish.
        river.processMove(1, 0);
        assertEquals("BF3 ---", river.toString());
        
        /* === (2) Testing Rule 3: Collision of two Animals of the same gender and species === */
        
        river = new River(2);
        river.river[0] = new Fish(2, Animal.Gender.MALE);
        river.river[1] = new Fish(3, Animal.Gender.MALE);
        
        // Fish
        
        assertEquals("FM2 FM3", river.toString());
        
        river.processMove(0, 1);
        assertEquals("FM2 FM3", river.toString());
        
        // Bears
        // 1. Same strength
        river.river[0] = new Bear(3, Animal.Gender.MALE);
        river.river[1] = new Bear(3, Animal.Gender.MALE);
        
        assertEquals("BM3 BM3", river.toString());
        
        river.processMove(0, 1);
        assertEquals("BM3 BM3", river.toString());
        
        // 2. Varying strength
        river.river[0] = new Bear(3, Animal.Gender.MALE);
        river.river[1] = new Bear(1, Animal.Gender.MALE);
        
        assertEquals("BM3 BM1", river.toString());
        
        river.processMove(0, 1);
        assertEquals("--- BM3", river.toString());
        
        /* === (3) Test Rule 4: Reproduction === */
        
        // Fish
        // Full array
        river = new River(2);
        river.river[0] = new Fish(2, Animal.Gender.MALE);
        river.river[1] = new Fish(2, Animal.Gender.FEMALE);
        
        assertEquals("FM2 FF2", river.toString());
        
        river.processMove(0, 1);
        assertEquals("FM2 FF2", river.toString());
        
        // Space in array
        
        river = new River(3);
        river.river[0] = new Fish(2, Animal.Gender.MALE);
        river.river[1] = new Fish(2, Animal.Gender.FEMALE);
        river.river[2] = null;
        
        assertEquals("FM2 FF2 ---", river.toString());
        
        river.processMove(0, 1);
        assertEquals(false, river.toString().equals("FM2 FF2 ---"));
        
        // Bears
        // Space in array
        
        river = new River(3);
        river.river[0] = new Bear(2, Animal.Gender.MALE);
        river.river[1] = new Bear(2, Animal.Gender.FEMALE);
        river.river[2] = null;
        
        assertEquals("BM2 BF2 ---", river.toString());
        
        river.processMove(0, 1);
        assertEquals(false, river.toString().equals("BM2 BF2 ---"));
        
        // Full array
        river = new River(2);
        river.river[0] = new Bear(2, Animal.Gender.MALE);
        river.river[1] = new Bear(2, Animal.Gender.FEMALE);
        
        assertEquals("BM2 BF2", river.toString());
        
        river.processMove(0, 1);
        assertEquals("BM2 BF2", river.toString());
        
    }
    
}
